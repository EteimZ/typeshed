from ..error_msgs import BATCH_EXECUTOR_SHUTDOWN_W as BATCH_EXECUTOR_SHUTDOWN_W, BATCH_REF_DEPRECATION_NEW_V14_CLS_NS_W as BATCH_REF_DEPRECATION_NEW_V14_CLS_NS_W, BATCH_REF_DEPRECATION_OLD_V14_CLS_NS_W as BATCH_REF_DEPRECATION_OLD_V14_CLS_NS_W
from ..exceptions import UnexpectedStatusCodeException as UnexpectedStatusCodeException
from ..util import check_batch_result as check_batch_result
from .requests import BatchRequest as BatchRequest, BatchResponse as BatchResponse, ObjectsBatchRequest as ObjectsBatchRequest, ReferenceBatchRequest as ReferenceBatchRequest
from concurrent.futures import ThreadPoolExecutor
from numbers import Real
from typing import Callable, List, Optional, Sequence, Tuple, Union
from weaviate.connect import Connection as Connection
from weaviate.data.replication import ConsistencyLevel as ConsistencyLevel
from weaviate.types import UUID as UUID

BatchRequestType = Union[ObjectsBatchRequest, ReferenceBatchRequest]

class WeaviateErrorRetryConf:
    number_retries: int
    errors_to_exclude: Optional[List[str]]
    errors_to_include: Optional[List[str]]
    def __post_init__(self) -> None: ...
    def __init__(self, number_retries, errors_to_exclude, errors_to_include) -> None: ...

class BatchExecutor(ThreadPoolExecutor):
    def is_shutdown(self) -> bool: ...

class Batch:
    def __init__(self, connection: Connection) -> None: ...
    def configure(self, batch_size: Optional[int] = ..., creation_time: Optional[Real] = ..., timeout_retries: int = ..., connection_error_retries: int = ..., weaviate_error_retries: Optional[WeaviateErrorRetryConf] = ..., callback: Optional[Callable[[dict], None]] = ..., dynamic: bool = ..., num_workers: int = ..., consistency_level: Optional[ConsistencyLevel] = ...) -> Batch: ...
    def __call__(self, batch_size: Optional[int] = ..., creation_time: Optional[Real] = ..., timeout_retries: int = ..., connection_error_retries: int = ..., weaviate_error_retries: Optional[WeaviateErrorRetryConf] = ..., callback: Optional[Callable[[dict], None]] = ..., dynamic: bool = ..., num_workers: int = ..., consistency_level: Optional[ConsistencyLevel] = ...) -> Batch: ...
    def add_data_object(self, data_object: dict, class_name: str, uuid: Optional[UUID] = ..., vector: Optional[Sequence] = ...) -> str: ...
    def add_reference(self, from_object_uuid: UUID, from_object_class_name: str, from_property_name: str, to_object_uuid: UUID, to_object_class_name: Optional[str] = ...) -> None: ...
    def create_objects(self) -> list: ...
    def create_references(self) -> list: ...
    def flush(self) -> None: ...
    def delete_objects(self, class_name: str, where: dict, output: str = ..., dry_run: bool = ...) -> dict: ...
    def num_objects(self) -> int: ...
    def num_references(self) -> int: ...
    def pop_object(self, index: int = ...) -> dict: ...
    def pop_reference(self, index: int = ...) -> dict: ...
    def empty_objects(self) -> None: ...
    def empty_references(self) -> None: ...
    def is_empty_objects(self) -> bool: ...
    def is_empty_references(self) -> bool: ...
    @property
    def shape(self) -> Tuple[int, int]: ...
    @property
    def batch_size(self) -> Optional[int]: ...
    @property
    def dynamic(self) -> bool: ...
    @property
    def consistency_level(self, value: Optional[Union[ConsistencyLevel, None]]) -> Union[str, None]: ...
    @property
    def recommended_num_objects(self) -> Optional[int]: ...
    @property
    def recommended_num_references(self) -> Optional[int]: ...
    def start(self) -> Batch: ...
    def shutdown(self) -> None: ...
    def __enter__(self) -> Batch: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    @property
    def creation_time(self) -> Real: ...
    @property
    def timeout_retries(self) -> int: ...
    @property
    def connection_error_retries(self) -> int: ...
